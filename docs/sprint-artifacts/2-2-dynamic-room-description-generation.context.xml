<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>2</storyId>
    <title>Dynamic Room Description Generation</title>
    <status>drafted</status>
    <generatedAt>2025-12-04</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/2-2-dynamic-room-description-generation.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>game designer</asA>
    <iWant>the AI to dynamically generate unique room descriptions based on the chosen theme and narrative</iWant>
    <soThat>each playthrough offers fresh environments</soThat>
    <tasks>
- [ ] AC 1: Extend `services/ai_service.py` to generate room descriptions.
  - [ ] Subtask: Implement a function to formulate prompts for room descriptions, incorporating current game `theme`, `location`, `narrative_state`, and `room_context` (from `GameSession`).
  - [ ] Subtask: Call the Gemini API to generate the room description.
- [ ] AC 1, 2: Create or update Flask API route for room description generation.
  - [ ] Subtask: Define a `POST /generate_room_description` endpoint in `routes.py`.
  - [ ] Subtask: This endpoint will receive context, call `services/ai_service.py`, and return the generated room description.
- [ ] AC 2: Integrate dynamic room descriptions with UI.
  - [ ] Subtask: Modify existing Jinja2 templates (e.g., `templates/game.html`) to display the dynamically generated room description.
- [ ] AC 1, 2: Implement unit and integration tests.
  - [ ] Subtask: Write unit tests for the room description generation logic in `services/ai_service.py`, mocking the Gemini API.
  - [ ] Subtask: Write integration tests for the `POST /generate_room_description` Flask route, verifying API interaction and proper display.
  - [ ] Subtask: Write E2E tests to visually confirm that dynamic room descriptions are displayed.
</tasks>
  </story>

  <acceptanceCriteria>
    <criterion>Given a game with a selected theme and an ongoing narrative, when the AI is prompted for a room description, including the theme and a narrative summary, then the AI generates a unique description for that room that is consistent with both the theme and the narrative.</criterion>
    <criterion>And this description is displayed to the player.</criterion>
</acceptanceCriteria>

  <artifacts>
<docs>
    <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document: AI Escape</title>
        <section>FR-001: Dynamic Content Generation</section>
        <snippet>The AI generates unique storylines, adapts puzzles, and creates room descriptions based on user input, ensuring no two games are are the same.</snippet>
    </doc>
    <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document: AI Escape</title>
        <section>FR-007: AI-Generated Narrative</section>
        <snippet>The core ability for the AI to create a unique story.</snippet>
    </doc>
    <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>AI Service Integration</section>
        <snippet>Utilizes Gemini Pro / Gemini 1.5 Pro for narrative generation.</snippet>
    </doc>
    <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>AI Client Library</section>
        <snippet>Employs `google-generativeai 0.8.5` for interacting with the Gemini API.</snippet>
    </doc>
    <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Prompt Management Strategy</section>
        <snippet>Relies on Structured Prompting with Narrative Archetypes to ensure coherence.</snippet>
    </doc>
    <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>API Pattern for AI interactions</section>
        <snippet>Flask API Routes will secure AI API keys and provide RESTful endpoints for frontend interaction with AI generation logic.</snippet>
    </doc>
    <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Game State Management & Persistence</section>
        <snippet>`GameSession.narrativeState` is crucial for context.</snippet>
    </doc>
    <doc>
        <path>docs/epics.md</path>
        <title>ibe160 - Epic Breakdown</title>
        <section>Epic 2: Introducing the AI Storyteller</section>
        <snippet>This Epic focuses on transitioning the "AI Escape" game from static, hard-coded story and room descriptions to dynamically generated content powered by AI.</snippet>
    </doc>
    <doc>
        <path>docs/epics.md</path>
        <title>ibe160 - Epic Breakdown</title>
        <section>Story 2.2: Dynamic Room Description Generation</section>
        <snippet>Story 2.2 focuses on implementing logic for the AI to generate unique room descriptions consistent with chosen themes and ongoing narratives.</snippet>
    </doc>
    <doc>
        <path>docs/ux-design-specification.md</path>
        <title>AI Escape - UX Design Specification</title>
        <section>5. User Journey Flows</section>
        <snippet>UX Design outlines user journey flows for New Game Creation and Load Game, which will rely on the backend's game state management to function correctly. This implies the need for dynamic content in the UI.</snippet>
    </doc>
</docs>
    <code>
        <code-ref>
            <path>services/ai_service.py</path>
            <kind>file</kind>
            <reason>Extend to generate room descriptions</reason>
        </code-ref>
        <code-ref>
            <path>routes.py</path>
            <kind>file</kind>
            <reason>Create or update Flask API route for room description generation</reason>
        </code-ref>
        <code-ref>
            <path>templates/game.html</path>
            <kind>file</kind>
            <reason>Modify to display dynamically generated room description</reason>
        </code-ref>
        <code-ref>
            <path>tests/</path>
            <kind>directory</kind>
            <reason>For new unit, integration, and E2E tests</reason>
        </code-ref>
    </code>
    <dependencies>
      <python>
        <package name="Flask" version="3.1.2" />
        <package name="python-dotenv" version="?" />
        <package name="gunicorn" version="?" />
        <package name="pytest" version="?" />
        <package name="google-generativeai" version="0.8.5" />
        <note>Core Python dependencies for the Flask application and Google Gemini API client.</note>
      </python>
      <node>
        <package name="playwright" version="?" />
        <note>Existing Node.js project dependencies for E2E testing.</note>
      </node>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>
        <type>Required Pattern</type>
        <description>Python Flask application structure (modular, with `app.py`, `static/`, `templates/`, `models.py`, `routes.py`, `services/`, `tests/`).</description>
        <source>docs/architecture.md#Project-Structure</source>
    </constraint>
    <constraint>
        <type>Required Pattern</type>
        <description>WCAG 2.1 Level AA accessibility compliance.</description>
        <source>docs/architecture.md#Accessibility-Implementation</source>
    </constraint>
    <constraint>
        <type>Required Pattern</type>
        <description>Stateless JWT Authentication.</description>
        <source>docs/architecture.md#Security-Architecture</source>
    </constraint>
    <constraint>
        <type>Layer Restriction</type>
        <description>Frontend (Jinja2 templates/Static assets) &lt;-> Backend (Flask Routes/API Endpoints).</description>
        <source>docs/architecture.md#Integration-Points</source>
    </constraint>
    <constraint>
        <type>Layer Restriction</type>
        <description>Flask Routes/API Endpoints &lt;-> AI Service (Gemini API).</description>
        <source>docs/architecture.md#Integration-Points</source>
    </constraint>
    <constraint>
        <type>Layer Restriction</type>
        <description>Flask Routes/API Endpoints &lt;-> Database (Supabase PostgreSQL via SQLAlchemy).</description>
        <source>docs/architecture.md#Integration-Points</source>
    </constraint>
    <constraint>
        <type>Testing Requirement</type>
        <description>Unit Tests (Pytest with `pytest-mock`).</description>
        <source>docs/architecture.md#Comprehensive-Testing-Strategy</source>
    </constraint>
    <constraint>
        <type>Testing Requirement</type>
        <description>Integration Tests (Pytest).</description>
        <source>docs/architecture.md#Comprehensive-Testing-Strategy</source>
    </constraint>
    <constraint>
        <type>Testing Requirement</type>
        <description>E2E Tests (Playwright).</description>
        <source>docs/architecture.md#Comprehensive-Testing-Strategy</source>
    </constraint>
    <constraint>
        <type>Coding Standard</type>
        <description>Python Classes: `PascalCase`, Python Functions/Variables: `snake_case`, Python Modules/Files: `snake_case`, Database Tables: `snake_case` (plural), Database Columns: `snake_case`, API Endpoints: `kebab-case` for URL paths, `snake_case` for query parameters, Constants: `SCREAMING_SNAKE_CASE`.</description>
        <source>docs/architecture.md#Consistency-Rules</source>
    </constraint>
    <constraint>
        <type>Coding Standard</type>
        <description>Code Organization: Modular Flask application layout.</description>
        <source>docs/architecture.md#Code-Organization</source>
    </constraint>
</constraints>

<interfaces></interfaces>
  <tests>
    <standards>
      <standard>
        <framework>Pytest</framework>
        <type>Unit, Integration</type>
        <note>Unit tests should mock the Gemini API.</note>
        <source>docs/architecture.md#Testing-Strategy</source>
      </standard>
      <standard>
        <framework>Playwright</framework>
        <type>E2E</type>
        <source>docs/architecture.md#Comprehensive-Testing-Strategy</source>
      </standard>
    </standards>
    <locations>
      <location>tests/</location>
      <note>Mirroring the application's module structure (e.g., `tests/unit/`, `tests/integration/`).</note>
    </locations>
    <ideas>
      <idea ac="1">
        <description>Write unit tests for the room description generation logic in `services/ai_service.py`, mocking the Gemini API.</description>
      </idea>
      <idea ac="2">
        <description>Write integration tests for the `POST /generate_room_description` Flask route, verifying API interaction and proper display.</description>
      </idea>
      <idea ac="2">
        <description>Write E2E tests to visually confirm that dynamic room descriptions are displayed.</description>
      </idea>
    </ideas>
  </tests>
</story-context>