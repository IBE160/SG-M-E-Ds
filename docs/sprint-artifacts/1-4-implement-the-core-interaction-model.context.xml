<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>4</storyId>
    <title>Implement the Core Interaction Model</title>
    <status>drafted</status>
    <generatedAt>2025-12-04</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-4-implement-the-core-interaction-model.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>player</asA>
    <iWant>to interact with the game world through a set of contextual options and a "go back" function</iWant>
    <soThat>I can navigate and solve puzzles</soThat>
    <tasks>
- [ ] AC 1: Define a mechanism for generating contextual options.
  - [ ] Subtask: Based on the current room and game state (from `GameSession`), dynamically generate a list of possible interactions.
- [ ] AC 1: Implement rendering of interaction options.
  - [ ] Subtask: Display the generated options as a numbered list in the UI using Jinja2 templates and `.option-btn` elements.
  - [ ] Subtask: Ensure accessibility with keyboard navigation and visible focus indicators.
- [ ] AC 2: Implement player input handling.
  - [ ] Subtask: Create a Flask route to receive player's selected option (e.g., a number corresponding to an action).
- [ ] AC 2: Integrate player choices with game logic.
  - [ ] Subtask: Process the player's input and update the `GameSession` accordingly (e.g., move to a new room, add item to inventory, trigger puzzle logic).
  - [ ] Subtask: Implement a "go back" function that reverts the player to the previous room or state.
- [ ] AC 1, 2: Implement unit and integration tests.
  - [ ] Subtask: Write unit tests for the contextual option generation logic.
  - [ ] Subtask: Write integration tests for Flask routes handling player input and verifying `GameSession` updates based on selected options.
  - [ ] Subtask: Write E2E tests to simulate player interaction and verify UI updates and game progression.
</tasks>
  </story>

  <acceptanceCriteria>
    <criterion>Given the player is in a room with a "locked door" and a "note", when the game presents interaction options, then the options are displayed as a numbered list, such as: `1. Examine the locked door`, `2. Read the note`, `3. Look around the room`, `4. Go back`.</criterion>
    <criterion>And the player can select an option by entering the corresponding number.</criterion>
</acceptanceCriteria>

  <artifacts>
<docs>
    <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document: AI Escape</title>
        <section>FR-003: Hybrid Interaction Model</section>
        <snippet>A blend of text-based commands for interaction combined with dynamic visual feedback.</snippet>
    </doc>
    <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document: AI Escape</title>
        <section>FR-004: Core Interaction Loop</section>
        <snippet>Players interact with rooms and objects through a system of contextual options and a "go back" function to navigate.</snippet>
    </doc>
    <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>API Pattern for AI interactions</section>
        <snippet>Flask API Routes will handle communication between the frontend and AI generation logic (relevant for any backend interaction).</snippet>
    </doc>
    <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>UX/UI</section>
        <snippet>User choices rendered as `.option-btn` elements. In-game navigation uses numbered options within the main text box (`.immersive-option`).</snippet>
    </doc>
    <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Game State Transition Flow</section>
        <snippet>The core game loop follows a well-defined state transition flow, managed by the backend: `GameSession` is created at "Start Game", and updated on "Player Action" and "AI Response & State Change" cycles.</snippet>
    </doc>
    <doc>
        <path>docs/epics.md</path>
        <title>ibe160 - Epic Breakdown</title>
        <section>Epic 1: Foundational Framework & A Single, Static Escape Room</section>
        <snippet>Epic 1 aims to build a robust technical foundation and a complete, testable, end-to-end user experience with a single, hard-coded story and puzzle chain.</snippet>
    </doc>
    <doc>
        <path>docs/epics.md</path>
        <title>ibe160 - Epic Breakdown</title>
        <section>Story 1.4: Implement the Core Interaction Model</section>
        <snippet>Story 1.4 focuses on developing a hybrid interaction model that allows players to navigate rooms and interact with objects through contextual text-based options and a "go back" function.</snippet>
    </doc>
    <doc>
        <path>docs/ux-design-specification.md</path>
        <title>AI Escape - UX Design Specification</title>
        <section>2. Visual Foundation</section>
        <snippet>The UX Design Specification outlines visual foundations (retro-futuristic colors, `Press Start 2P`, `Roboto Mono` fonts), responsive design strategy for mobile/tablet/desktop, and an accessibility strategy targeting WCAG 2.1 Level AA compliance.</snippet>
    </doc>
</docs>
    <code>
        <code-ref>
            <path>ai-escape-app/app.py</path>
            <kind>file</kind>
            <reason>Main Flask application entry point for routing</reason>
        </code-ref>
        <code-ref>
            <path>ai-escape-app/routes.py</path>
            <kind>file</kind>
            <reason>Contains Flask routes for player interaction</reason>
        </code-ref>
        <code-ref>
            <path>ai-escape-app/services/game_logic.py</path>
            <kind>file</kind>
            <reason>Contains game logic for processing player input and updating GameSession</reason>
        </code-ref>
        <code-ref>
            <path>ai-escape-app/templates/</path>
            <kind>directory</kind>
            <reason>For Jinja2 HTML templates to display interaction options</reason>
        </code-ref>
        <code-ref>
            <path>ai-escape-app/tests/</path>
            <kind>directory</kind>
            <reason>For unit, integration, and E2E tests related to interaction model</reason>
        </code-ref>
    </code>
    <dependencies>
      <python>
        <package name="Flask" version="3.1.2" />
        <package name="python-dotenv" version="?" />
        <package name="gunicorn" version="?" />
        <package name="pytest" version="?" />
        <note>Core Python dependencies for the Flask application.</note>
      </python>
      <node>
        <package name="playwright" version="?" />
        <note>Existing Node.js project dependencies for E2E testing.</note>
      </node>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>
        <type>Required Pattern</type>
        <description>Python Flask application structure (modular, with `app.py`, `static/`, `templates/`, `models.py`, `routes.py`, `services/`, `tests/`).</description>
        <source>docs/architecture.md#Project-Structure</source>
    </constraint>
    <constraint>
        <type>Required Pattern</type>
        <description>WCAG 2.1 Level AA accessibility compliance.</description>
        <source>docs/architecture.md#Accessibility-Implementation</source>
    </constraint>
    <constraint>
        <type>Required Pattern</type>
        <description>Stateless JWT Authentication.</description>
        <source>docs/architecture.md#Security-Architecture</source>
    </constraint>
    <constraint>
        <type>Layer Restriction</type>
        <description>Frontend (Jinja2 templates/Static assets) &lt;-> Backend (Flask Routes/API Endpoints).</description>
        <source>docs/architecture.md#Integration-Points</source>
    </constraint>
    <constraint>
        <type>Layer Restriction</type>
        <description>Flask Routes/API Endpoints &lt;-> AI Service (Gemini API).</description>
        <source>docs/architecture.md#Integration-Points</source>
    </constraint>
    <constraint>
        <type>Layer Restriction</type>
        <description>Flask Routes/API Endpoints &lt;-> Database (Supabase PostgreSQL via SQLAlchemy).</description>
        <source>docs/architecture.md#Integration-Points</source>
    </constraint>
    <constraint>
        <type>Testing Requirement</type>
        <description>Unit Tests (Pytest with `pytest-mock`).</description>
        <source>docs/architecture.md#Comprehensive-Testing-Strategy</source>
    </constraint>
    <constraint>
        <type>Testing Requirement</type>
        <description>Integration Tests (Pytest).</description>
        <source>docs/architecture.md#Comprehensive-Testing-Strategy</source>
    </constraint>
    <constraint>
        <type>Testing Requirement</type>
        <description>E2E Tests (Playwright).</description>
        <source>docs/architecture.md#Comprehensive-Testing-Strategy</source>
    </constraint>
    <constraint>
        <type>Coding Standard</type>
        <description>Python Classes: `PascalCase`, Python Functions/Variables: `snake_case`, Python Modules/Files: `snake_case`, Database Tables: `snake_case` (plural), Database Columns: `snake_case`, API Endpoints: `kebab-case` for URL paths, `snake_case` for query parameters, Constants: `SCREAMING_SNAKE_CASE`.</description>
        <source>docs/architecture.md#Consistency-Rules</source>
    </constraint>
    <constraint>
        <type>Coding Standard</type>
        <description>Code Organization: Modular Flask application layout.</description>
        <source>docs/architecture.md#Code-Organization</source>
    </constraint>
</constraints>

<interfaces></interfaces>
  <tests>
    <standards>
      <standard>
        <framework>Pytest</framework>
        <type>Unit, Integration</type>
        <note>Use `pytest-mock` for unit testing isolation if needed.</note>
        <source>docs/architecture.md#Comprehensive-Testing-Strategy</source>
      </standard>
      <standard>
        <framework>Playwright</framework>
        <type>E2E</type>
        <source>docs/architecture.md#Comprehensive-Testing-Strategy</source>
      </standard>
    </standards>
    <locations>
      <location>tests/</location>
      <note>Mirroring the application's module structure (e.g., `tests/unit/`, `tests/integration/`).</note>
    </locations>
    <ideas>
      <idea ac="1">
        <description>Write unit tests for the contextual option generation logic.</description>
      </idea>
      <idea ac="2">
        <description>Write integration tests for Flask routes handling player input and verifying `GameSession` updates based on selected options.</description>
      </idea>
      <idea ac="2">
        <description>Write E2E tests to simulate player interaction and verify UI updates and game progression.</description>
      </idea>
    </ideas>
  </tests>
</story-context>